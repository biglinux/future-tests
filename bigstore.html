<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="css/beer.min.css" rel="stylesheet">
    <script src="js/stonejs.js"></script>
    <script>window._ = Stone.gettext;</script>
    <script src="js/htmx.js"></script>
    <script src="js/alpine/cdn.min.js" defer></script>
    <script src="js/htmx.js"></script>
    <script type="module" src="js/alpine/module.cjs.min.js" defer></script>
    <script type="module" src="js/beer.min.js"></script>
    <script type="module" src="js/material-dynamic-colors.min.js"></script>
  </head>
<body class="light">
<!-- The previous lines add many features that are expected in scripts using recent versions of bigbashview -->

<div x-data="getItems()">

    <!-- Header section -->
    <header>
        <nav>
            <!-- Menu button -->
            <button class="circle transparent">
                <i>menu</i>
            </button>
            
            <!-- Search bar -->
            <h5 class="max center-align">
                <!-- Switches for search sources -->
                <div>
                    <label>
                        <input type="checkbox" x-model="searchPacman">
                        Pacman
                    </label>
                    <label>
                        <input type="checkbox" x-model="searchAUR">
                        AUR
                    </label>
                </div>
                
                <div class="field prefix round fill">
                    <i class="front">search</i>
                    <input x-ref="searchInput" x-on:keyup.enter="performSearch" placeholder="Search...">
                    <a x-on:click="performSearch" class="circle transparent">
                        <i>keyboard_return</i>
                    </a>
                </div>
            </h5>
        </nav>
    </header>

    <!-- Grid of items -->
    <div class="grid no-padding center-align middle-align">
        <template x-for="item in displayedItems">
            <div class="s12 m6 l3">
                <a class="round vertical" x-on:click="_run(item.exec)">
                    <div class="item-info">
                        <span x-text="item.package"></span><br>
                        <span x-text="item.description"></span><br>
                        Instalado: <span x-text="item.installed"></span>
                    </div>
                    <a class="tooltip bottom medium-space horizontal" x-show="item.description" x-text="item.description"></a>
                </a>
            </div>
        </template>
    </div>

    <button x-show="displayedItems.length < filteredItems.length" x-on:click="loadMore" class="btn">Show More</button>

    <script>
        function getItems() {
            let lastSearchState = {
                search: '',
                searchPacman: false,
                searchAUR: false
            };
            let lastFilteredResults = [];
            let searchTerms = [];
    
            return {
                search: '',
                pacmanData: [],
                aurData: [],
                maxItems: 50,
                translatedDescriptions: {},
                searchPacman: true,
                searchAUR: true,
        
                init() {
                    fetch('summary_apps_pt_BR.json')
                        .then(response => response.json())
                        .then(data => {
                            this.translatedDescriptions = data;
                            return fetch('search_pacman_jq.sh');
                        })
                        .then(response => response.json())
                        .then(data => {
                            data.forEach(item => {
                                if (this.translatedDescriptions[item.package]) {
                                    item.description = this.translatedDescriptions[item.package].summary;
                                }
                                item.source = 'pacman';
                                item.searchPackage = item.package && typeof item.package === 'string' ? removeAccents(item.package.toLowerCase()) : '';
                                item.searchDescription = item.description && typeof item.description === 'string' ? removeAccents(item.description.toLowerCase()) : '';
                            });
                            this.pacmanData = data;
                            return fetch('aur_filtered.json');
                        })
                        .then(response => response.json())
                        .then(aurData => {
                            aurData.forEach(item => {
                                item.package = item.Name;
                                item.description = item.Description;
                                if (this.translatedDescriptions[item.package]) {
                                    item.description = this.translatedDescriptions[item.package].summary;
                                }
                                item.source = 'aur';
                                item.searchPackage = item.package && typeof item.package === 'string' ? removeAccents(item.package.toLowerCase()) : '';
                                item.searchDescription = item.description && typeof item.description === 'string' ? removeAccents(item.description.toLowerCase()) : '';
                            });
                            this.aurData = aurData;
                        })
                        .catch(error => {
                            console.error("Error during data fetching or processing:", error);
                        });
                },
    
                performSearch() {
                    this.search = this.$refs.searchInput.value;
                    // Split search terms once
                    searchTerms = removeAccents(this.search.toLowerCase()).split(/\s+/);
                    // Reset memoized results
                    lastSearchState = {
                        search: '',
                        searchPacman: false,
                        searchAUR: false
                    };
                    lastFilteredResults = [];
                },
    
                filterData(data) {
                    if (this.search === '') {
                        return data; // Return the original data if there's no search term
                    }
                    
                    const matchPackage = [];
                    const matchDescription = [];
                    
                    data.forEach(item => {
                        if (searchTerms.every(term => item.searchPackage.includes(term))) {
                            matchPackage.push(item);
                        } else if (searchTerms.every(term => item.searchDescription.includes(term))) {
                            matchDescription.push(item);
                        }
                    });
    
                    return [...matchPackage, ...matchDescription];
                },
    
                get filteredItems() {
                    if (this.search === lastSearchState.search && 
                        this.searchPacman === lastSearchState.searchPacman && 
                        this.searchAUR === lastSearchState.searchAUR) {
                        return lastFilteredResults;
                    }
    
                    let results = [];
                    if (this.searchPacman) results = results.concat(this.filterData(this.pacmanData));
                    if (this.searchAUR) results = results.concat(this.filterData(this.aurData));
    
                    // Update the memoized state
                    lastSearchState = {
                        search: this.search,
                        searchPacman: this.searchPacman,
                        searchAUR: this.searchAUR
                    };
                    lastFilteredResults = results;
    
                    return results;
                },
    
                get displayedItems() {
                    return this.filteredItems.slice(0, this.maxItems);
                },
    
                loadMore() {
                    this.maxItems += 50;
                }
            };
        }
    
        function removeAccents(str) {
            return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
        }
    </script>